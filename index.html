<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Image Gallery with Enhanced Combat Grid and Initiative Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Cinzel', serif;
      background: #f4e4bc url("https://www.transparenttextures.com/patterns/aged-paper.png") repeat;
      background-blend-mode: overlay;
      color: #4a2c0f;
    }
    .dark {
      background-color: #1a1a1a;
      color: #fafafa;
      background-blend-mode: normal;
    }
    .combat-grid {
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      background: url("https://www.transparenttextures.com/patterns/parchment.png") repeat;
      background-color: #f9efd4;
    }
    .dark .combat-grid {
      background-color: #333;
    }
    .grid-cell {
      transition: all 0.2s;
      position: relative;
    }
    .grid-cell:hover {
      opacity: 0.8;
    }
    .token {
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      transition: transform 0.2s;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      text-shadow: 0px 0px 2px #fff, 0px 0px 4px #fff;
    }
    .token:hover {
      transform: scale(1.1);
    }
    .token-party {
      background: radial-gradient(circle, #4a89dc, #1a4c8f);
    }
    .token-enemy {
      background: radial-gradient(circle, #e74c3c, #7f1d1d);
    }
    .token-neutral {
      background: radial-gradient(circle, #f1c40f, #b7950b);
    }
    .coordinate {
      font-size: 10px;
      position: absolute;
      top: 1px;
      left: 1px;
      color: #888;
    }
  </style>
</head>
<body class="text-gray-800">
  <div id="root" class="p-4"></div>
  <script type="text/babel">
    /** Dark Mode Toggle */
    function DarkModeToggle() {
      const [darkMode, setDarkMode] = React.useState(() => localStorage.getItem("darkMode") === "true");
      React.useEffect(() => {
        if (darkMode) document.body.classList.add("dark");
        else document.body.classList.remove("dark");
        localStorage.setItem("darkMode", darkMode);
      }, [darkMode]);
      return (
        <button className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800" onClick={() => setDarkMode(!darkMode)}>
          {darkMode ? "Light Mode" : "Dark Mode"}
        </button>
      );
    }

    /** Backup Local Storage */
    function backupLocalStorage() {
      const data = JSON.stringify(localStorage);
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "backup.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    /** Restore Local Storage */
    function restoreLocalStorage(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          Object.keys(data).forEach((key) => {
            localStorage.setItem(key, data[key]);
          });
          alert("Local storage restored successfully. Please refresh the page.");
        } catch (err) {
          alert("Failed to restore local storage. Invalid file.");
        }
      };
      reader.readAsText(file);
    }

    /** Copy for Prompt */
    function copyForPrompt() {
      const content = document.getElementById("root").innerText;
      navigator.clipboard.writeText(content).then(() => {
        alert("Content copied to clipboard!");
      }).catch(() => {
        alert("Failed to copy content.");
      });
    }

    /** Enhanced Combat Grid Component */
    function CombatGrid() {
      // Get grid state from localStorage or use default empty grid
      const [tokens, setTokens] = React.useState(() => {
        const saved = localStorage.getItem("combatGridTokens");
        return saved ? JSON.parse(saved) : [];
      });
      const [gridSize, setGridSize] = React.useState(() => {
        const saved = localStorage.getItem("combatGridSize");
        return saved ? JSON.parse(saved) : { rows: 15, cols: 15 };
      });
      const [showCoordinates, setShowCoordinates] = React.useState(() => {
        const saved = localStorage.getItem("showGridCoordinates");
        return saved ? JSON.parse(saved) : true;
      });
      const [tokenType, setTokenType] = React.useState("party");
      const [tokenName, setTokenName] = React.useState("");
      const [tokenHP, setTokenHP] = React.useState("");
      const [selectedToken, setSelectedToken] = React.useState(null);
      const [terrainMode, setTerrainMode] = React.useState(false);
      const [selectedTerrain, setSelectedTerrain] = React.useState("difficult");

      // Save tokens to localStorage when they change
      React.useEffect(() => {
        localStorage.setItem("combatGridTokens", JSON.stringify(tokens));
      }, [tokens]);

      // Save grid size to localStorage when it changes
      React.useEffect(() => {
        localStorage.setItem("combatGridSize", JSON.stringify(gridSize));
      }, [gridSize]);

      // Save coordinate preference to localStorage
      React.useEffect(() => {
        localStorage.setItem("showGridCoordinates", JSON.stringify(showCoordinates));
      }, [showCoordinates]);

      // Add token to the grid
      const handleCellClick = (row, col) => {
        if (terrainMode) {
          // Add terrain to the cell
          setTokens(prev => {
            // Check if a terrain already exists at this position
            const terrainIndex = prev.findIndex(t => 
              t.row === row && t.col === col && t.isTerrain
            );
            
            // If terrain exists, remove it, otherwise add new terrain
            if (terrainIndex >= 0) {
              return prev.filter((_, i) => i !== terrainIndex);
            } else {
              return [...prev, {
                id: Date.now() + Math.random(),
                name: selectedTerrain,
                type: "terrain",
                isTerrain: true,
                row,
                col
              }];
            }
          });
        } else if (tokenName.trim()) {
          // Add a new token with the entered name
          setTokens(prev => [...prev, {
            id: Date.now() + Math.random(),
            name: tokenName.trim(),
            type: tokenType,
            hp: tokenHP.trim() ? parseInt(tokenHP.trim()) : null,
            maxHp: tokenHP.trim() ? parseInt(tokenHP.trim()) : null,
            row,
            col
          }]);
          setTokenName("");
          setTokenHP("");
        }
      };

      // Helper function to get terrain class
      const getTerrainClass = (terrain) => {
        switch(terrain) {
          case "difficult": return "bg-yellow-200 bg-opacity-60";
          case "water": return "bg-blue-200 bg-opacity-60";
          case "wall": return "bg-gray-600";
          case "door": return "bg-amber-800";
          default: return "bg-transparent";
        }
      };

      // Remove a token
      const removeToken = (id) => {
        setTokens(prev => prev.filter(token => token.id !== id));
      };

      // Select a token for moving
      const selectToken = (token) => {
        setSelectedToken(token);
      };

      // Move a token to a new cell
      const moveToken = (row, col) => {
        if (selectedToken) {
          setTokens(prev => prev.map(token => 
            token.id === selectedToken.id 
              ? { ...token, row, col } 
              : token
          ));
          setSelectedToken(null);
        }
      };

      // Update a token's HP
      const updateTokenHP = (id, newHP) => {
        setTokens(prev => prev.map(token => 
          token.id === id 
            ? { ...token, hp: Math.max(0, parseInt(newHP)) } 
            : token
        ));
      };

      // Reset grid
      const resetGrid = () => {
        if (confirm("Are you sure you want to clear the grid?")) {
          setTokens([]);
        }
      };

      // Render cells and tokens
      const renderGrid = () => {
        const cells = [];
        for (let row = 0; row < gridSize.rows; row++) {
          for (let col = 0; col < gridSize.cols; col++) {
            // Find terrain at this position
            const terrain = tokens.find(t => 
              t.isTerrain && t.row === row && t.col === col
            );
            
            // Find token at this position
            const token = tokens.find(t => 
              !t.isTerrain && t.row === row && t.col === col
            );

            // Create grid cell
            cells.push(
              <div 
                key={`${row}-${col}`} 
                className={`grid-cell border border-gray-400 ${terrain ? getTerrainClass(terrain.name) : 'hover:bg-gray-200'}`}
                onClick={() => token ? selectToken(token) : selectedToken ? moveToken(row, col) : handleCellClick(row, col)}
                style={{ cursor: selectedToken ? 'cell' : 'pointer' }}
              >
                {showCoordinates && (
                  <span className="coordinate">{String.fromCharCode(65 + col)}{row + 1}</span>
                )}
                
                {token && (
                  <div 
                    className={`token rounded-full w-10 h-10 text-xs flex flex-col token-${token.type}`}
                    onClick={(e) => { e.stopPropagation(); selectToken(token); }}
                  >
                    <span className="truncate max-w-8 text-center">{token.name}</span>
                    {token.hp !== null && (
                      <span className="text-xs">{token.hp}/{token.maxHp}</span>
                    )}
                  </div>
                )}
              </div>
            );
          }
        }
        return cells;
      };

      // Calculate grid cell size based on grid dimensions
      const cellSize = Math.min(Math.floor(600 / gridSize.cols), Math.floor(600 / gridSize.rows));

      return (
        <div>
          <div className="mb-4 space-y-2">
            <div className="flex flex-wrap gap-2 mb-2">
              <input
                type="text"
                value={tokenName}
                onChange={(e) => setTokenName(e.target.value)}
                placeholder="Token Name"
                className="border p-1 rounded"
                disabled={terrainMode}
              />
              
              <input
                type="number"
                value={tokenHP}
                onChange={(e) => setTokenHP(e.target.value)}
                placeholder="HP (optional)"
                className="border p-1 rounded w-32"
                disabled={terrainMode}
              />
              
              <select
                value={tokenType}
                onChange={(e) => setTokenType(e.target.value)}
                className="border p-1 rounded"
                disabled={terrainMode}
              >
                <option value="party">Party</option>
                <option value="enemy">Enemy</option>
                <option value="neutral">Neutral</option>
              </select>
              
              <button 
                className={`px-3 py-1 ${terrainMode ? 'bg-green-700' : 'bg-gray-500'} text-white rounded`}
                onClick={() => setTerrainMode(!terrainMode)}
              >
                {terrainMode ? 'Terrain Mode: ON' : 'Terrain Mode: OFF'}
              </button>
              
              {terrainMode && (
                <select
                  value={selectedTerrain}
                  onChange={(e) => setSelectedTerrain(e.target.value)}
                  className="border p-1 rounded"
                >
                  <option value="difficult">Difficult Terrain</option>
                  <option value="water">Water</option>
                  <option value="wall">Wall</option>
                  <option value="door">Door</option>
                </select>
              )}
            </div>
            
            <div className="flex flex-wrap gap-2 mb-2">
              <div className="flex items-center gap-1">
                <label>Rows:</label>
                <input
                  type="number"
                  min="5"
                  max="30"
                  value={gridSize.rows}
                  onChange={(e) => setGridSize({...gridSize, rows: Math.min(30, Math.max(5, parseInt(e.target.value) || 5))})}
                  className="border p-1 rounded w-16"
                />
              </div>
              
              <div className="flex items-center gap-1">
                <label>Columns:</label>
                <input
                  type="number"
                  min="5"
                  max="30"
                  value={gridSize.cols}
                  onChange={(e) => setGridSize({...gridSize, cols: Math.min(30, Math.max(5, parseInt(e.target.value) || 5))})}
                  className="border p-1 rounded w-16"
                />
              </div>
              
              <div className="flex items-center gap-1">
                <input
                  type="checkbox"
                  checked={showCoordinates}
                  onChange={() => setShowCoordinates(!showCoordinates)}
                  id="show-coordinates"
                />
                <label htmlFor="show-coordinates">Show Coordinates</label>
              </div>
              
              <button 
                onClick={resetGrid}
                className="px-3 py-1 bg-red-500 text-white rounded ml-auto"
              >
                Reset Grid
              </button>
            </div>
            
            <div className="text-sm">
              {selectedToken ? (
                <div className="bg-amber-100 p-2 rounded">
                  <p>Moving: {selectedToken.name} - Click on a cell to place or <button onClick={() => setSelectedToken(null)} className="underline text-blue-600">cancel</button></p>
                </div>
              ) : (
                <div>
                  {terrainMode ? 
                    "Click on cells to add/remove terrain features" : 
                    "Enter a name and click a cell to add a token"
                  }
                </div>
              )}
            </div>
          </div>

          <div className="combat-grid rounded-lg border-2 border-amber-900 overflow-hidden">
            <div 
              className="grid" 
              style={{
                display: 'grid',
                gridTemplateColumns: `repeat(${gridSize.cols}, ${cellSize}px)`,
                gridTemplateRows: `repeat(${gridSize.rows}, ${cellSize}px)`,
              }}
            >
              {renderGrid()}
            </div>
          </div>

          <div className="mt-4">
            <h3 className="text-lg font-bold mb-2">Token Management</h3>
            <div className="max-h-60 overflow-y-auto">
              <table className="w-full text-sm">
                <thead className="bg-amber-100">
                  <tr>
                    <th className="p-1 text-left">Name</th>
                    <th className="p-1 text-left">Type</th>
                    <th className="p-1 text-left">HP</th>
                    <th className="p-1 text-center">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {tokens.filter(t => !t.isTerrain).map(token => (
                    <tr key={token.id} className="border-b">
                      <td className="p-1">{token.name}</td>
                      <td className="p-1">
                        <span className={`inline-block w-3 h-3 rounded-full bg-${token.type === 'party' ? 'blue' : token.type === 'enemy' ? 'red' : 'yellow'}-500 mr-1`}></span>
                        {token.type}
                      </td>
                      <td className="p-1">
                        {token.hp !== null ? (
                          <input
                            type="number"
                            value={token.hp}
                            onChange={(e) => updateTokenHP(token.id, e.target.value)}
                            className="border p-0.5 w-16 text-center"
                          />
                        ) : "N/A"}
                      </td>
                      <td className="p-1 text-center">
                        <button 
                          onClick={() => selectToken(token)}
                          className="px-2 py-0.5 bg-amber-600 text-white rounded text-xs mr-1"
                        >
                          Move
                        </button>
                        <button 
                          onClick={() => removeToken(token.id)}
                          className="px-2 py-0.5 bg-red-500 text-white rounded text-xs"
                        >
                          Remove
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    }

    /** Enhanced Initiative Tracker Component */
    function InitiativeTracker() {
      const [participants, setParticipants] = React.useState(() => {
        const saved = localStorage.getItem("initiativeTrackerData");
        return saved ? JSON.parse(saved) : [];
      });
      const [newName, setNewName] = React.useState("");
      const [newType, setNewType] = React.useState("party");
      const [newHP, setNewHP] = React.useState("");
      const [newDexMod, setNewDexMod] = React.useState("0");
      const [currentTurn, setCurrentTurn] = React.useState(0);
      const [round, setRound] = React.useState(1);
      
      // Save to localStorage when participants change
      React.useEffect(() => {
        localStorage.setItem("initiativeTrackerData", JSON.stringify(participants));
      }, [participants]);
      
      const addParticipant = () => {
        if (newName.trim()) {
          setParticipants((prev) => [
            ...prev,
            { 
              id: Date.now() + Math.random(), 
              name: newName.trim(), 
              type: newType, 
              initiative: null,
              hp: newHP.trim() ? parseInt(newHP.trim()) : null,
              maxHp: newHP.trim() ? parseInt(newHP.trim()) : null,
              dexMod: parseInt(newDexMod) || 0,
              conditions: [],
              notes: ""
            },
          ]);
          setNewName("");
          setNewHP("");
          setNewDexMod("0");
        }
      };
      
      const removeParticipant = (id) => {
        setParticipants((prev) => prev.filter((p) => p.id !== id));
      };
      
      const setInitiative = (id, value) => {
        setParticipants((prev) =>
          prev.map((p) => (p.id === id ? { ...p, initiative: value === "" ? null : Number(value) } : p))
        );
      };
      
      const rollInitiative = () => {
        setParticipants((prev) =>
          prev.map((p) =>
            p.initiative === null ? { ...p, initiative: Math.floor(Math.random() * 20) + 1 + p.dexMod } : p
          )
        );
      };
      
      const updateHP = (id, newHP) => {
        setParticipants((prev) =>
          prev.map((p) => (p.id === id ? { ...p, hp: Math.max(0, parseInt(newHP)) } : p))
        );
      };
      
      const updateNotes = (id, notes) => {
        setParticipants((prev) =>
          prev.map((p) => (p.id === id ? { ...p, notes } : p))
        );
      };
      
      const toggleCondition = (id, condition) => {
        setParticipants((prev) =>
          prev.map((p) => {
            if (p.id === id) {
              const conditions = [...p.conditions];
              const index = conditions.indexOf(condition);
              if (index >= 0) {
                conditions.splice(index, 1);
              } else {
                conditions.push(condition);
              }
              return { ...p, conditions };
            }
            return p;
          })
        );
      };
      
      const nextTurn = () => {
        const sortedParticipants = [...participants].sort(sortInitiative);
        if (sortedParticipants.length === 0) return;
        
        setCurrentTurn((prev) => {
          const nextTurn = prev + 1;
          if (nextTurn >= sortedParticipants.length) {
            setRound((prevRound) => prevRound + 1);
            return 0;
          }
          return nextTurn;
        });
      };
      
      const resetTurn = () => {
        setCurrentTurn(0);
        setRound(1);
      };
      
      const resetCombat = () => {
        if (confirm("Are you sure you want to reset combat? All initiatives will be cleared.")) {
          setParticipants((prev) =>
            prev.map((p) => ({ ...p, initiative: null }))
          );
          resetTurn();
        }
      };
      
      // Sort by initiative, breaking ties with dexterity modifier
      const sortInitiative = (a, b) => {
        if (a.initiative === null && b.initiative === null) return 0;
        if (a.initiative === null) return 1;
        if (b.initiative === null) return -1;
        if (a.initiative === b.initiative) return b.dexMod - a.dexMod;
        return b.initiative - a.initiative;
      };
      
      const sortedParticipants = [...participants].sort(sortInitiative);
      
      return (
        <div className="mt-4">
          <h3 className="text-xl font-bold mb-2">Initiative Tracker</h3>
          
          <div className="flex flex-wrap gap-2 mb-2">
            <input
              type="text"
              value={newName}
              onChange={(e) => setNewName(e.target.value)}
              placeholder="Name"
              className="border p-1 rounded"
            />
            
            <select
              value={newType}
              onChange={(e) => setNewType(e.target.value)}
              className="border p-1 rounded"
            >
              <option value="party">Party</option>
              <option value="enemy">Enemy</option>
              <option value="neutral">Neutral</option>
            </select>
            
            <input
              type="number"
              value={newHP}
              onChange={(e) => setNewHP(e.target.value)}
              placeholder="HP (optional)"
              className="border p-1 rounded w-20"
            />
            
            <div className="flex items-center">
              <label className="mr-1">DEX mod:</label>
              <input
                type="number"
                value={newDexMod}
                onChange={(e) => setNewDexMod(e.target.value)}
                className="border p-1 rounded w-14"
              />
            </div>
            
            <button onClick={addParticipant} className="px-2 py-1 bg-green-500 text-white rounded">Add</button>
          </div>
          
          <div className="flex gap-2 mb-4">
            <div className="bg-amber-100 p-2 rounded flex items-center">
              <span className="font-bold mr-2">Round: {round}</span>
              {sortedParticipants.length > 0 && (
                <span className="font-bold">
                  Current: {currentTurn < sortedParticipants.length ? sortedParticipants[currentTurn].name : "None"}
                </span>
              )}
            </div>
            
            <button onClick={rollInitiative} className="px-3 py-1 bg-blue-500 text-white rounded">
              Roll Initiative
            </button>
            
            <button onClick={nextTurn} className="px-3 py-1 bg-green-600 text-white rounded" disabled={sortedParticipants.length === 0}>
              Next Turn
            </button>
            
            <button onClick={resetCombat} className="px-3 py-1 bg-red-500 text-white rounded">
              Reset Combat
            </button>
          </div>
          
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="bg-amber-100">
                <tr>
                  <th className="p-1 text-left">Initiative</th>
                  <th className="p-1 text-left">Name</th>
                  <th className="p-1 text-left">Type</th>
                  <th className="p-1 text-left">HP</th>
                  <th className="p-1 text-left">Conditions</th>
                  <th className="p-1 text-left">Notes</th>
                  <th className="p-1 text-center">Actions</th>
                </tr>
              </thead>
              <tbody>
                {sortedParticipants.map((p, index) => (
                  <tr key={p.id} className={`${index === currentTurn ? 'bg-yellow-100' : ''} border-b`}>
                    <td className="p-1">
                      <div className="flex items-center">
                        <input
                          type="number"
                          value={p.initiative !== null ? p.initiative : ""}
                          onChange={(e) => setInitiative(p.id, e.target.value)}
                          className="border p-0.5 rounded w-14"
                        />
                        <button
                          onClick={() => setInitiative(p.id, Math.floor(Math.random() * 20) + 1 + p.dexMod)}
                          className="ml-1 px-1 py-0.5 bg-blue-500 text-white rounded text-xs"
                        >
                          Roll
                        </button>
                      </div>
                    </td>
                    <td className="p-1 font-medium">{p.name}</td>
                    <td className="p-1">
                      <span className={`inline-block w-3 h-3 rounded-full bg-${p.type === 'party' ? 'blue' : p.type === 'enemy' ? 'red' : 'yellow'}-500 mr-1`}></span>
                      {p.type}
                    </td>
                    <td className="p-1">
                      {p.hp !== null ? (
                        <div className="flex items-center">
                          <input
                            type="number"
                            value={p.hp}
                            onChange={(e) => updateHP(p.id, e.target.value)}
                            className="border p-0.5 w-14 text-center"
                          />
                          <span className="ml-1">/ {p.maxHp}</span>
                        </div>
                      ) : "â€”"}
                    </td>
                    <td className="p-1">
                      <div className="flex flex-wrap gap-1">
                        {['Poisoned', 'Stunned', 'Prone'].map(condition => (
                          <button
                            key={condition}
                            className={`px-1 py-0.5 text-xs rounded ${p.conditions.includes(condition) ? 'bg-purple-600 text-white' : 'bg-gray-200'}`}
                            onClick={() => toggleCondition(p.id, condition)}
                          >
                            {condition}
                          </button>
                        ))}
                      </div>
                    </td>
                    <td className="p-1">
                      <input
                        type="text"
                        value={p.notes}
                        onChange={(e) => updateNotes(p.id, e.target.value)}
                        placeholder="Add notes"
                        className="border p-0.5 w-full"
                      />
                    </td>
                    <td className="p-1 whitespace-nowrap">
                      <button
                        onClick={() => removeParticipant(p.id)}
                        className="px-2 py-0.5 bg-red-500 text-white rounded text-xs"
                      >
                        Remove
                      </button>
                    </td>
                  </tr>
                ))}
                {sortedParticipants.length === 0 && (
                  <tr>
                    <td colSpan="7" className="p-2 text-center text-gray-500">No participants yet. Add some to start tracking initiative.</td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    /** Image Gallery Component */
    function ImageGallery() {
      const [images, setImages] = React.useState(() => {
        const saved = localStorage.getItem("galleryImages");
        return saved ? JSON.parse(saved) : [];
      });
      function saveImagesToLocalStorage(newImages) {
        try {
          localStorage.setItem("galleryImages", JSON.stringify(newImages));
        } catch (error) {
          alert("Storage error. Try deleting some images.");
        }
      }
      function handleImageUpload(event) {
        const files = event.target.files;
        if (files && images.length < 2) {
          const newImages = Array.from(files).slice(0, 2 - images.length);
          const newImageData = [];
          newImages.forEach((file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              newImageData.push({ id: Date.now() + Math.random(), src: e.target.result });
              if (newImageData.length === newImages.length) {
                const updatedImages = [...images, ...newImageData];
                setImages(updatedImages);
                saveImagesToLocalStorage(updatedImages);
              }
            };
            reader.readAsDataURL(file);
          });
        } else if (images.length >= 2) {
          alert("Maximum of 2 images reached. Delete some to add more.");
        }
      }
      function handleDeleteImage(imageId) {
        const updatedImages = images.filter((img) => img.id !== imageId);
        setImages(updatedImages);
        saveImagesToLocalStorage(updatedImages);
      }
      return (
        <div className="container mx-auto p-4 space-y-4">
          <div className="flex flex-wrap justify-between items-center mb-4 gap-2">
            <DarkModeToggle />
            <button className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800" onClick={backupLocalStorage}>
              Backup Local Storage
            </button>
            <label className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800 cursor-pointer">
              Restore Data
              <input type="file" accept=".json" onChange={restoreLocalStorage} className="hidden" />
            </label>
            <button className="px-3 py-1 bg-amber-700 text-white rounded hover:bg-amber-800" onClick={copyForPrompt}>
              Copy for Prompt
            </button>
          </div>
          
          <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-md">
            <h2 className="text-xl font-bold mb-2">Image Gallery</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Upload Images (Max 2)</label>
              <input
                type="file"
                accept="image/*"
                multiple
                onChange={handleImageUpload}
                className="border p-1 rounded text-sm"
                disabled={images.length >= 2}
              />
              <p className="text-sm text-gray-700 dark:text-gray-300 mt-1">{images.length}/2 images uploaded</p>
            </div>
            {images.length > 0 ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                {images.map((image) => (
                  <div key={image.id} className="relative max-w-3xl mx-auto">
                    <img
                      src={image.src}
                      alt="Gallery Image"
                      className="w-full h-auto object-contain rounded-lg shadow"
                    />
                    <button
                      className="absolute top-2 right-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                      onClick={() => handleDeleteImage(image.id)}
                    >
                      Delete
                    </button>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-sm text-gray-700 dark:text-gray-300">No images uploaded yet.</p>
            )}
          </div>
          
          <div className="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg shadow-md">
            <h2 className="text-xl font-bold mb-2">D&D Combat Tracker</h2>
            <CombatGrid />
            <InitiativeTracker />
          </div>
        </div>
      );
    }

    ReactDOM.render(<ImageGallery />, document.getElementById("root"));
  </script>
</body>
</html>
